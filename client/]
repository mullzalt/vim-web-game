import { GameAction } from "@/lib/vim-game";
import {
  Decoration,
  EditorView,
  Line,
  StateEffect,
} from "@uiw/react-codemirror";
import {
  Change,
  diffArrays,
  diffChars,
  diffLines,
  diffWordsWithSpace,
} from "diff";
import {
  addDecoration,
  lineWidget,
  filterDecoration,
} from "@/lib/codemirror/cm-decoration";
import { addTooltip, filterTooltip } from "@/lib/codemirror/cm-tooltip";

type DocDiff = {
  from: number;
  to: number;
  removed?: boolean;
  added?: boolean;
  lineBreak?: boolean;
  replace?: boolean;
  value: string;
};

function searchString(string: string, search: string, from = 0) {
  const index = string.indexOf(search, from);
  console.log(string.indexOf("hello"), string);

  if (index === -1) return undefined;

  return {
    from: index + from,
    to: index + search.length - 1,
    text: string.slice(index + from, index + search.length - 1),
  };
}

export function updateView(
  view: EditorView,
  action: GameAction,
  safeCode: string,
) {
  const doc = view.state.doc.toString();
  let code = safeCode;
  const effects: StateEffect<any>[] = [];

  if (action.action === "select" && doc === code) {
    const max = doc.length;
    let { head, anchor } = action.selection;
    head = head === anchor ? head + 1 : head;

    effects.push(
      addDecoration.of([
        Decoration.mark({
          class: "border-2 border-yellow-400",
        }).range(Math.min(anchor, max), Math.min(head, max)),
      ]),
    );
  }

  if (action.action === "modify") {
    code = action.after;
  }

  let currentLine = 1;
  diffArrays(doc.split("\n"), code.split("\n")).map((diff, index) => {
    const { value, added, removed } = diff;

    if (removed) {
      value.map((_, j) => {
        effects.push(
          addDecoration.of([
            Decoration.line({
              class: "bg-red-200/10",
            }).range(view.state.doc.line(currentLine + j).from),
          ]),
        );
      });
    }

    currentLine += added ? 0 : value.length;
  });

  let currentFrom = 0;
  diffChars(doc, code).map((diff) => {
    const { value, added, removed } = diff;
    const from = currentFrom;
    const to = from + value.length;
    const posAdd = added ? 0 : value.length;

    const hasNewLine = diff.value.match(/\n/);

    if (diff.added && hasNewLine) {
      console.log(searchString(doc, value));
      effects.push(
        addDecoration.of([
          Decoration.widget({
            widget: new lineWidget(diff.value.replace(/\n/, "")),
            block: true,
            side: 1,
          }).range(from),
        ]),
      );
    }

    if (added && !hasNewLine) {
      effects.push(
        addTooltip.of({
          text: diff.value.replace(/\n/g, "↵").replace(/^\s/, "␣"),
          pos: from,
        }),
      );
    }

    if (removed) {
      effects.push(
        addDecoration.of([
          Decoration.mark({
            class: "bg-red-400",
          }).range(from, to),
        ]),
      );
    }

    currentFrom += posAdd;
  });

  view.dispatch({
    effects: [
      filterDecoration.of(() => false),
      filterTooltip.of(null),
      ...effects.reverse(),
    ],
  });
}

export function _updateView(
  view: EditorView,
  action: GameAction,
  safeCode: string,
) {
  const doc = view.state.doc.toString();
  let code = safeCode;
  let diffBy: "any" | "word" | "line" = "any";
  const effects: StateEffect<any>[] = [];

  switch (action.action) {
    case "select": {
      let { head, anchor } = action.selection;
      head = head === anchor ? head + 1 : head;

      if (anchor > doc.length || head > doc.length) break;
      if (anchor < 0 || head < 0) break;

      if (doc !== code) break;

      effects.push(
        addDecoration.of([
          Decoration.mark({
            class: "border-2 border-yellow-400",
          }).range(anchor, head),
        ]),
      );

      break;
    }
    case "modify": {
      code = action.after;
      diffBy = "line";
      break;
    }
    default: {
      break;
    }
  }

  let lastIndex = 0;
  let prevRange = 0;

  function mapChange(diff: Change) {
    const hasNewLine = diff.value.match(/\n/);

    if (diff.added && hasNewLine) {
      effects.push(
        addDecoration.of([
          Decoration.widget({
            widget: new lineWidget(diff.value.replace(/\n/, "")),
            block: true,
            side: 0,
          }).range(prevRange),
        ]),
      );
      return;
    }

    if (diff.added) {
      effects.push(
        addTooltip.of({
          text: diff.value.replace(/\n/g, "↵").replace(/^\s/, "␣"),
          pos: prevRange,
        }),
      );
      return;
    }

    prevRange += diff.value.length;
    const anchor = doc.indexOf(diff.value, lastIndex);
    const head = anchor + diff.value.length;
    if (anchor < 0) {
      return;
    }

    lastIndex = head;
    // if (!diff.removed && !diff.added) {
    //   return;
    // }

    if (diff.removed && hasNewLine) {
      const isDocEnd = head >= doc.length;
      let pos = isDocEnd ? head : anchor;

      effects.push(
        addDecoration.of([
          Decoration.line({
            class: "bg-red-800",
          }).range(pos),
        ]),
      );
      return;
    }

    if (diff.removed) {
      effects.push(
        addDecoration.of([
          Decoration.mark({
            class: "bg-red-800",
          }).range(anchor, head),
        ]),
      );
      return;
    }
  }

  switch (diffBy) {
    case "any": {
      diffChars(doc, code).map(mapChange);

      break;
    }
    case "word": {
      diffWordsWithSpace(doc, code).map(mapChange);
      break;
    }
    case "line": {
      diffLines(doc, code, {
        newlineIsToken: true,
        ignoreWhitespace: false,
      }).map(mapChange);
      break;
    }
  }

  view.dispatch({
    effects: [
      filterDecoration.of(() => false),
      filterTooltip.of(null),
      ...effects.reverse(),
    ],
  });

  return;
}
